/* FanController MK2
 * By Karl Kristian Dyrholm Torp
 * Arduino Pro Micro
 * 128x32 I2C OLED. SDA - D2, SCL - D3
 * Potmeter on ACD input A1
 * FAN tachometer input on D7
 * FAN PWM output on D10
 */

#include <Arduino.h>
#include <U8g2lib.h>
#include <Wire.h>

#define Fan_icon_size 32
const unsigned char Fan1_bits[] PROGMEM = {
   0xfe, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x0f, 0xf0, 0xcf,
   0xf3, 0x03, 0xc6, 0xcf, 0xff, 0x0e, 0x3e, 0xff, 0x7f, 0x1f, 0x7e, 0xfe,
   0xbf, 0x3f, 0xfe, 0xfc, 0xdf, 0x3f, 0xfe, 0xf8, 0xcf, 0x7f, 0x7e, 0xf0,
   0xcf, 0x7f, 0x7e, 0xf0, 0x07, 0xfe, 0x3e, 0xe0, 0x07, 0xf8, 0x3f, 0xee,
   0x07, 0xf0, 0x1f, 0xef, 0xc3, 0xff, 0xdf, 0xdf, 0xf3, 0xff, 0xff, 0xdf,
   0xfb, 0xff, 0xff, 0xdf, 0xfb, 0xff, 0xff, 0xdf, 0xfb, 0xff, 0xff, 0xcf,
   0xfb, 0xfb, 0xff, 0xc3, 0xf7, 0xf8, 0x0f, 0xe0, 0x77, 0xf8, 0x1f, 0xe0,
   0x07, 0x7c, 0x7f, 0xe0, 0x0f, 0x7e, 0xfe, 0xf3, 0x0f, 0x7e, 0xfe, 0xf3,
   0x1f, 0x7f, 0xfc, 0xfb, 0x3f, 0x7f, 0xf8, 0xfd, 0x7f, 0x7e, 0xf8, 0xfe,
   0xff, 0x7c, 0x70, 0xff, 0xf3, 0x63, 0xc0, 0xcf, 0xf3, 0x0f, 0xf0, 0xcf,
   0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0x7f };

const unsigned char Fan2_bits[] PROGMEM = {
   0xfe, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x1f, 0xf8, 0xcf,
   0xf3, 0xe3, 0xc1, 0xcf, 0xff, 0xf8, 0x03, 0xff, 0x7f, 0xf8, 0x03, 0xfe,
   0x3f, 0xf8, 0xc7, 0xfd, 0x1f, 0xf0, 0xc7, 0xfb, 0xcf, 0xe0, 0xc7, 0xf7,
   0xef, 0xe3, 0xe7, 0xff, 0xf7, 0xc7, 0xe7, 0xef, 0xf7, 0xff, 0xf7, 0xef,
   0xf3, 0xff, 0xff, 0xc7, 0xfb, 0xff, 0xff, 0xc3, 0xfb, 0xff, 0xff, 0xc0,
   0x03, 0xf8, 0x3f, 0xc0, 0x03, 0xfc, 0x1f, 0xc0, 0x03, 0xff, 0xff, 0xdf,
   0x83, 0xff, 0xff, 0xdf, 0xe3, 0xff, 0xff, 0xcf, 0xf7, 0xef, 0xff, 0xef,
   0xf7, 0xe7, 0xf3, 0xef, 0xff, 0xe7, 0xc7, 0xf7, 0xef, 0xe3, 0x07, 0xf3,
   0xdf, 0xe3, 0x0f, 0xf8, 0xbf, 0xe3, 0x1f, 0xfc, 0x7f, 0xc0, 0x1f, 0xfe,
   0xff, 0xc0, 0x1f, 0xff, 0xf3, 0x83, 0xc7, 0xcf, 0xf3, 0x1f, 0xf8, 0xcf,
   0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0x7f };


#define tachometer_pin 7
#define pwm_pin 10
#define pot_pin 1

U8G2_SSD1306_128X32_UNIVISION_F_HW_I2C u8g2(U8G2_R2, U8X8_PIN_NONE, SCL, SDA);
uint8_t fan_icon_state = 0;
uint16_t average[10] = {0,0,0,0,0,0,0,0,0,0};
uint8_t average_index = 0;
uint8_t zero_rpm_readings = 0;
uint16_t avgRpm = 0;

uint16_t updateAverage(uint16_t newVal)
{
  uint32_t avg = 0;
  average[average_index++] = newVal;
  if(average_index > 9) {
    average_index = 0;
  }
  for(uint8_t i = 0; i < 10; ++i){
    avg += average[i];
  }
  return avg / 10;
}

void setup(void) {
  pinMode(tachometer_pin, INPUT_PULLUP);
  pinMode(pwm_pin, OUTPUT);
  setup_pwm_25khz();
  set_compare_reg(250);

  //delay(2000); // Some OLEDs are not ready to communicate right after power-up.
  u8g2.begin();
}

void set_compare_reg(uint16_t val)
{
  OCR1B = val;    
}

void setup_pwm_25khz()
{
  TCCR1A =  _BV(COM1B1) | _BV(WGM11);               // Enable PWM outputs for  OC1B on digital pin 10
  TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10);     // Set fast PWM and prescaler of 1 (none) on timer 1
  ICR1 = 650;                                       // Set the PWM frequency to ~25kHz (16MHz / (prescaler * (ICR1 + 1)))
}

void update_screen(uint8_t dutyCycle, uint16_t rpm)
{
  u8g2.clearBuffer();

  if(rpm != 0) {
    u8g2.setFont(u8g2_font_ncenB12_tr);
    u8g2.setCursor(42,13);
    u8g2.print(dutyCycle);
    u8g2.print(" %");
    u8g2.setCursor(42,28);
    u8g2.print(rpm);
    u8g2.print(" rpm");
  } else {
    u8g2.setFont(u8g2_font_ncenB18_tr);
    u8g2.setCursor(42,24);
    u8g2.print(dutyCycle);
    u8g2.print(" %");
  }

  if(fan_icon_state || (!dutyCycle && !rpm)) {
    u8g2.drawXBMP(0, 0, Fan_icon_size, Fan_icon_size, Fan2_bits);
    fan_icon_state = 0;
  } else {
    u8g2.drawXBMP(0, 0, Fan_icon_size, Fan_icon_size, Fan1_bits);
    fan_icon_state = 1;
  }  
  u8g2.sendBuffer();
}

uint16_t getInverted10bit(uint16_t value)
{
  return 1023 - value;
}

uint16_t getAvgPotReading()
{
  uint8_t i = 0;
  uint32_t value = 0;
  for(i = 0; i < 32; ++i){
    value += getInverted10bit(analogRead(pot_pin));
  }
  return value / 32;
}

uint16_t getRpm()
{
  float rpm = 0;

  int duration = pulseIn(tachometer_pin, HIGH, 100000);
  if(duration) {
    rpm = (1.0 / ((float)duration / 1000000)) * 15;
  }
  
  return (uint16_t)rpm;
}

void loop(void) {
  uint16_t potRead = getAvgPotReading();
  uint16_t dutyCycle = potRead / 10;
  if(dutyCycle > 100) {
    dutyCycle = 100;
  }
  
  set_compare_reg(potRead * 0.635);
  
  uint16_t rpm = getRpm();

  if(rpm && rpm < 4000){
    zero_rpm_readings = 0;
    avgRpm = updateAverage(rpm);
  } else {
    zero_rpm_readings++;
    if(zero_rpm_readings >= 10) {
      zero_rpm_readings = 10;
      avgRpm = 0;
    }
  }
  update_screen(dutyCycle, avgRpm);

  delay(50); 
}
